
Варианты работы (это принципы работы - мысли разраба):
1. В режими реального времени разрабор;
2. Сначала пройтись - нормализовать, а потом уже анализировать;


Приветствуем вас в нашей программе:

---=== ПОИСК МОСТОВ В ГРАФЕ 3000 ===---

Общая концепция:
Программа получает на вход коллекцию ребёр, которые представлены парой чисел
(* (родитель;потомок) - 1 и 2), для которох есть тип MyPair. 
Эти числа являются идентификаторами объектов, которые
предствалены кнопками. Связь между обектами происходи по средством появления 
прямой линии между ними (основана на их координатах).
Поиск мостов происходит по принципу "поиск в глубину".

Конкретная работа программы:
Есть два вида составления графа: первый в ручную создание объектов, а потом их соединение,
а второй - генерация автоматически, про их работу напишет наш специалист по дизайну МАРК.

МАРК, пиши здесь:
...

В результате такого создания графа (обоих способов) получается Список 
(это Лист/Коллекция, как хотите, но дальше буду называть список).
Алгоритм по анализу графа (описывает главный системный программист - АЛЕКСАНДР)
работает так: сначала объявляется переменная этого типа, дальше вызывается 
функция инициализации, в которую и передают тот самый список рёбер.
А в ней вызывается функция для предварительного обхода графа, т.е. 
она проходит все возможноные пути и правильным образом переворачивает
(если нужно) значения рёбер (наши пары в списке). Это позволяет сразу
нормализовать все рёбра и причесать их к виду ОТЕЦ - ПОТОМОК
(это в разы упростит дальнейшую работу, в противном случае будет такой гемор!!!
Вы бы знали... Даже не хочу объяснять).
P.S. Просто рёбра могут иметь вид 1-2 или 2-1 - это плохо, не наш принцип работы,
поэтому мы всё перевернём, поэтому и нужна нормализация.

                    Принцип нормализации
Управление потоком происходит за счёт списка "отцов". При нахождении следующего
ребра его ПОТОМОК добавляется в этот список, что послужит дальнейшему движению.

Из этого списка удаление происходит по средством проверки, а есть ли у этого
ОТЦА ещё дети (при нахождении ребра оно удаляется из списка, нормализуется
и запихивается в другой лист (промежуточный), который по завершению присвоим первоначальному)

 --- Меточка ---
 Всего 2 функции имеют в названии цифру, это говорит о их принадлежности к
 нормализации (1) или же уже анализу графа (2).

(здесь начинается реальная работа)
Дальше вызывается функция пошагового анализа (вызывается либо при помощи кнопки,
либо при помощи функции автоход). 

                    Принцип                     
При каждом шаге у нас записываются данные в 3 переменные (РЕЗУЛЬТИРУЮЩИЕ):
переменная анализируемого ребра, список рёбер и не рёбер (они чистятся каждый ход).
Они же на ружу и выводятся и на основе их меняется цвет рёбер.

Когда граф становится пуст выводится соответствующий флаг конца.

--- ВНИМАНИЕ ---
Здесь поиск следующего элемента происхолит строго по ОТЦУ, т.е. только 
первое значение пары сравнивается.
Удаление рёбер происходит только при получении двух результатов:
ЭТО МОСТЫ и ЭТО НЕ МОСТЫ.
Для правильного очищения НЕ МОСТОВ используется список, хранящий все
рёбра, которые мы прошли (дальше поймёте почему).

При нахождении нужного ребра оно подвергается проверке:
1.Если есть ребро, где ПОТОМОК этого ребар является ОТЦОМ, то следующее;
2.Если у него нет продолжения, т.е. ПОТОМОК этого ребра не является
ОТЦОМ како-нибудь следующего, то это МОСТ.
Здесь просто удаляется это ребро и его ПОТОМОК, который уже добавился
как потенциальный ОТЕЦ, а также вносится в нужную переменную;
3. НЕ МОСТОМ является ребро, если его ПОТОМОК уже есть в списке РОДИТЕЛЕЙ,
тогда все рёбра на пути, которые были до этого числа становятся НЁ РЁБРАМИ
(как раз для этого и нужен был список с историей хода) -> из всех списков
удаляются эти ребра и заносятся в список не рёбра.

--- Метка ---
При работе с листами часто использовалась функция Reverse() - это
нужно, чтобы обеспечить удаление последнего элемента ВСЕГДА.

Ну как-то так я и разработал этот алгоритм. Все подробности в коде.