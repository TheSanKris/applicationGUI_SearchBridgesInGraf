
Варианты работы:
1. В режими реального времени разрабор;
2. Сначала пройтись - нормализовать, а потом уже анализировать;


Приветствуем вас в нашей программе:

---=== ПОИСК МОСТОВ В ГРАФЕ 3000 ===---

Общая концепция:
Программа получает на вход массив ребёр, которые представлены парой чисел
(* (родитель;потомок) - 1 и 2), для которох есть тип MyPair. 
Эти числа являются идентификаторами объектов, которые
предствалены кнопками. Связь между обектами происходи по средством появления 
прямой линии между ними (основана на их координатах).
Поиск мостов происходит по принципу "поиск в глубину".

Конкретная работа программы:
Есть два вида составления графа: первый в ручную создание объектов, а потом их соединение,
а второй - генерация автоматически, про их работу напишет наш специалист по дизайну МАРК.

МАРК, пиши здесь:
...

В результате такого создания графа (обоих способов) получается Список 
(это Лист/Коллекция, как хотите, но дальше буду называть список).
Алгоритм по анализу графа (описывает главный системный программист - АЛЕКСАНДР)
работает так: сначала объявляется переменная этого типа, дальше вызывается 
функция инициализации, в которую и передают тот самый список рёбер.

(здесь начинается реальная работа)
Дальше вызывается функция пошагового анализа (вызывается либо при помощи кнопки,
либо при помощи функции автоход). 

                    Принцип                     
 Алгоритм работает так: выбирается ребро, где родителем является точка старта (номер 1)
 для всех точек родителей предназначен список с соотв. названием, он пригодится для
 запоминания номеров отцов, чтобы можно легко было возвращаться по иерархии вверх, 
 что нужно для поиска новых ребёр от этого отца.
 Поиск осуществялется при помощи спецальной функции, ищущей ребра с помощью номера родителя,
 независимо первым или вторым значением он ялвляется в паре (может генерироваьтся пара
 так, что родитель второй, а не первый), также, если ребро находится в неправильном формате,
 то переворачивает его (для дальнейшего удобства работы => избежание множества условий)
 Также данное ребро сохраняется в буферный список - это требуется для запоминания пути,
 по которому мы шли и ускоряет процесс удаления ребёр из общего списка рёбер
 (во избежание повторного анализа рёбер они будут удальться из общего списка рёбер, так как
 следующее ребро мы ищем как раз в общем списке рёбер).
 Следующим шагом требуется определить является ли потомок ребра, которое мы нашли
 по номеру родителя, УЗЛОМ (анализ определения моста и различных графов привёл к тому,
 что можно сделать вывод: при получении информации, что одно из наших ребёр (из списка буфер)
 ведёт к узлу, то получается, что все предыдущие на нашем пути рёбра не являются мостами)
 Как раз для этого мы заводим два списка рёбер: "наш путь" и "узлы".
 ----- МЕТКА -----
 Чтобы правильно записывалось в узлы значение, должно выполняться 1 из 2 условий:
 список пуст или номер, который мы хотим добавить не лежит в списке.

 Для выполнения нужно действия с нужным ребром (ну и объектом графа соответственно)
 используется система флагов. Всего 3: "следующий", просто скипаем; "это не мост",говорит
 что этот и все ребёра до узла не являются мостави; "это мост", говорит, что это ребро -
 мост (только для 1 ребра).
 Чтобы узнать кем является это ребро вызывается функция, работает по такому принципу:
 она проверяет, является ли потомок этого ребра родителем другого, если же нет, то
 это ребро является последним на пути и не имеет продолжение - следовательно оно не
 может как-то придти к узлу, а значит оно является мостом.
 Дальше же происходит проверка, а ведёт ли это ребро к узлу (всё просто, является ли номер
 потомка этого ребра узлом) если нет, то просто переходим к следующему ребру.